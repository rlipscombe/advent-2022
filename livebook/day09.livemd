# Rope Bridge

```elixir
Mix.install([
  {:kino, "~> 0.8.0"},
  {:kino_vega_lite, "~> 0.1.7"},
  {:vega_lite, "~> 0.1.6"}
])

alias VegaLite, as: Vl
```

## Instructions

```elixir
input = Kino.Input.textarea("Input:")
```

```elixir
instructions =
  Kino.Input.read(input)
  |> String.trim()
  |> String.split("\n")
  |> Enum.map(fn i ->
    [direction, distance] = String.split(i, " ")
    {direction, String.to_integer(distance)}
  end)
```

## Expand Instructions

If we want to run an animation, we need to see the individual steps. The easiest way to do that is to convert the instructions into single steps, so that "D 3" becomes "D 1, D 1, D 1" and so on.

```elixir
steps =
  Enum.flat_map(instructions, fn
    {direction, distance} -> for _ <- 1..distance, do: direction
  end)
```

## Part 1

```elixir
defmodule Part1 do
  def init(steps), do: {{0, 0}, {0, 0}, bounds(steps), MapSet.new()}

  def bounds(steps) do
    {visited, final} =
      Enum.map_reduce(steps, {0, 0}, fn
        "D", {x, y} -> {{x, y - 1}, {x, y - 1}}
        "U", {x, y} -> {{x, y + 1}, {x, y + 1}}
        "L", {x, y} -> {{x - 1, y}, {x - 1, y}}
        "R", {x, y} -> {{x + 1, y}, {x + 1, y}}
      end)

    {{min_x, _}, {max_x, _}} = visited |> Enum.min_max_by(fn {x, _y} -> x end)
    {{_, min_y}, {_, max_y}} = visited |> Enum.min_max_by(fn {_x, y} -> y end)
    bounds = {min_x..max_x, min_y..max_y}
    bounds
  end

  def run(steps) do
    Enum.reduce(steps, init(steps), &step/2)
  end

  def step(step, state = {head, tail, bounds, visited}) do
    head = move(head, step)
    tail = chase(tail, head)
    {head, tail, bounds, MapSet.put(visited, tail)}
  end

  def move({x, y}, "R"), do: {x + 1, y}
  def move({x, y}, "U"), do: {x, y + 1}
  def move({x, y}, "L"), do: {x - 1, y}
  def move({x, y}, "D"), do: {x, y - 1}

  # The head and tail must always be touching.
  def chase(tail = {tx, ty}, _head = {hx, hy})
      when hx - 1 <= tx and tx <= hx + 1 and hy - 1 <= ty and ty <= hy + 1,
      do: tail

  def chase(_tail = {tx, ty}, _head = {hx, hy}), do: {tx + sign(hx - tx), ty + sign(hy - ty)}

  def sign(value) when value < 0, do: -1
  def sign(value) when value == 0, do: 0
  def sign(value) when value > 0, do: 1
end
```

```elixir
{_h, _t, _bounds, visited} = Part1.run(steps)
Enum.count(visited)
```

```elixir
defmodule Render do
  def heatmap(_state = {head, tail, _bounds = {x_scale, y_scale}, visited}) do
    visited_points =
      Enum.map(visited, fn {x, y} ->
        %{x: x, y: y}
      end)

    visited_layer =
      Vl.new()
      |> Vl.mark(:rect)
      |> Vl.data(values: visited_points)
      |> Vl.encode_field(:x, "x", scale: [domain: Enum.to_list(x_scale)])
      |> Vl.encode_field(:y, "y", scale: [domain: Enum.to_list(y_scale) |> Enum.reverse()])

    knot_points = [knot_point(head, "H"), knot_point(tail, "T")]

    text_layer =
      Vl.new()
      |> Vl.mark(:text)
      |> Vl.data(values: knot_points)
      |> Vl.encode_field(:x, "x")
      |> Vl.encode_field(:y, "y")
      |> Vl.encode_field(:text, "text")

    Vl.new(width: 600, height: 600)
    |> Vl.layers([visited_layer, text_layer])
  end

  defp knot_point({x, y}, text), do: %{x: x, y: y, text: text}
end
```

```elixir
Render.heatmap(Part1.run(steps))
```
